using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Metal.NET.Generator;

[Generator(LanguageNames.CSharp)]
public class MetalBindingsGenerator : IIncrementalGenerator
{
    private static readonly JsonSerializerOptions s_jsonOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        ReadCommentHandling = JsonCommentHandling.Skip,
        AllowTrailingCommas = true,
    };

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Collect all .json files marked as AdditionalFiles
        var jsonFiles = context.AdditionalTextsProvider
            .Where(static f => f.Path.EndsWith(".json"))
            .Select(static (text, ct) => (
                FileName: Path.GetFileNameWithoutExtension(text.Path),
                Content: text.GetText(ct)?.ToString() ?? ""));

        context.RegisterSourceOutput(jsonFiles.Collect(), Execute);
    }

    private void Execute(SourceProductionContext ctx,
        ImmutableArray<(string FileName, string Content)> files)
    {
        foreach (var (fileName, content) in files)
        {
            if (string.IsNullOrWhiteSpace(content)) continue;

            if (fileName == "enums")
            {
                GenerateEnums(ctx, content);
            }
            else if (fileName == "structs")
            {
                GenerateStructs(ctx, content);
            }
            else
            {
                // Assume it's an ObjC class/protocol definition
                GenerateObjCClass(ctx, fileName, content);
            }
        }
    }

    // ──────────────────── Enum generation ────────────────────

    private void GenerateEnums(SourceProductionContext ctx, string json)
    {
        var file = JsonSerializer.Deserialize<EnumsFile>(json, s_jsonOptions);
        if (file?.Enums == null) return;

        foreach (var e in file.Enums)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("namespace Metal.NET;");
            sb.AppendLine();

            if (e.IsFlags) sb.AppendLine("[System.Flags]");
            sb.AppendLine($"public enum {e.Name} : {e.UnderlyingType}");
            sb.AppendLine("{");
            for (int i = 0; i < e.Members.Count; i++)
            {
                var m = e.Members[i];
                var comma = i < e.Members.Count - 1 ? "," : "";
                sb.AppendLine($"    {m.Name} = {m.Value}{comma}");
            }
            sb.AppendLine("}");

            ctx.AddSource($"{e.Name}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    // ──────────────────── Struct generation ────────────────────

    private void GenerateStructs(SourceProductionContext ctx, string json)
    {
        var file = JsonSerializer.Deserialize<StructsFile>(json, s_jsonOptions);
        if (file?.Structs == null) return;

        foreach (var s in file.Structs)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System.Runtime.InteropServices;");
            sb.AppendLine();
            sb.AppendLine("namespace Metal.NET;");
            sb.AppendLine();
            sb.AppendLine("[StructLayout(LayoutKind.Sequential)]");
            sb.AppendLine($"public struct {s.Name}");
            sb.AppendLine("{");
            foreach (var f in s.Fields)
            {
                sb.AppendLine($"    public {f.Type} {f.Name};");
            }
            sb.AppendLine("}");

            ctx.AddSource($"{s.Name}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    // ──────────────────── ObjC class / protocol generation ────────────────────

    private void GenerateObjCClass(SourceProductionContext ctx, string fileName, string json)
    {
        var def = JsonSerializer.Deserialize<ObjCClassDef>(json, s_jsonOptions);
        if (def == null) return;

        // Collect all unique selectors we need
        var selectors = new Dictionary<string, string>(); // selectorString -> fieldName

        foreach (var p in def.Properties)
        {
            var getSel = p.GetSelector ?? p.Name;
            AddSelector(selectors, getSel);
            if (!p.Readonly)
            {
                var setSel = p.SetSelector ?? $"set{Capitalize(p.Name)}:";
                AddSelector(selectors, setSel);
            }
        }
        foreach (var m in def.Methods) AddSelector(selectors, m.Selector);
        foreach (var m in def.StaticMethods) AddSelector(selectors, m.Selector);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();
        sb.AppendLine("namespace Metal.NET;");
        sb.AppendLine();

        // ── Selector cache ──
        sb.AppendLine($"internal static class {def.Name}_Selectors");
        sb.AppendLine("{");
        foreach (var kv in selectors)
        {
            sb.AppendLine($"    internal static readonly Selector {kv.Value} = Selector.Register(\"{kv.Key}\");");
        }
        sb.AppendLine("}");
        sb.AppendLine();

        // ── Struct wrapper ──
        sb.AppendLine("[StructLayout(LayoutKind.Sequential)]");
        sb.AppendLine($"public readonly struct {def.Name}");
        sb.AppendLine("{");
        sb.AppendLine("    public readonly IntPtr NativePtr;");
        sb.AppendLine();
        sb.AppendLine($"    public {def.Name}(IntPtr ptr) => NativePtr = ptr;");
        sb.AppendLine();
        sb.AppendLine("    public bool IsNull => NativePtr == IntPtr.Zero;");
        sb.AppendLine();
        sb.AppendLine($"    public static implicit operator IntPtr({def.Name} o) => o.NativePtr;");
        sb.AppendLine($"    public static implicit operator {def.Name}(IntPtr ptr) => new {def.Name}(ptr);");
        sb.AppendLine();

        // ── Alloc (for classes) ──
        if (def.IsClass && def.ObjCClass != null)
        {
            sb.AppendLine($"    private static readonly IntPtr s_class = ObjectiveCRuntime.GetClass(\"{def.ObjCClass}\");");
            sb.AppendLine();
            sb.AppendLine($"    public static {def.Name} Alloc()");
            sb.AppendLine("    {");
            sb.AppendLine("        var ptr = ObjectiveCRuntime.intptr_objc_msgSend(s_class, Selector.Register(\"alloc\"));");
            sb.AppendLine($"        return new {def.Name}(ptr);");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine($"    public {def.Name} Init()");
            sb.AppendLine("    {");
            sb.AppendLine("        var ptr = ObjectiveCRuntime.intptr_objc_msgSend(NativePtr, Selector.Register(\"init\"));");
            sb.AppendLine($"        return new {def.Name}(ptr);");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine($"    public static {def.Name} New()");
            sb.AppendLine("    {");
            sb.AppendLine("        return Alloc().Init();");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // ── Properties ──
        foreach (var p in def.Properties)
        {
            var getSel = SelectorFieldName(p.GetSelector ?? p.Name);
            var retCSharp = MapReturnCall(p.Type);

            // Skip properties whose getter returns a value struct (needs objc_msgSend_stret)
            if (retCSharp.Invoke.Contains("TODO"))
            {
                sb.AppendLine($"    // TODO: {p.Name} (value-struct return type {p.Type} requires objc_msgSend_stret)");
                sb.AppendLine();
                continue;
            }

            sb.AppendLine($"    public {p.Type} {p.Name}");
            sb.AppendLine("    {");
            sb.AppendLine($"        get => {WrapReturn(p.Type, $"{retCSharp.Invoke}(NativePtr, {def.Name}_Selectors.{getSel})")};");

            if (!p.Readonly)
            {
                var setSel = SelectorFieldName(p.SetSelector ?? $"set{Capitalize(p.Name)}:");
                var setCall = MapSetCall(p.Type);
                sb.AppendLine($"        set => ObjectiveCRuntime.{setCall}(NativePtr, {def.Name}_Selectors.{setSel}, {UnwrapParam(p.Type, "value")});");
            }
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // ── Instance methods ──
        foreach (var m in def.Methods)
        {
            EmitMethod(sb, def.Name, m, isStatic: false);
        }

        // ── Static methods ──
        foreach (var m in def.StaticMethods)
        {
            EmitMethod(sb, def.Name, m, isStatic: true);
        }

        // Retain / Release helpers
        sb.AppendLine("    public void Retain() => ObjectiveCRuntime.Retain(NativePtr);");
        sb.AppendLine("    public void Release() => ObjectiveCRuntime.Release(NativePtr);");

        sb.AppendLine("}");

        ctx.AddSource($"{def.Name}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    // ── Helpers ──

    private void EmitMethod(StringBuilder sb, string typeName, MethodDef m, bool isStatic)
    {
        var selField = $"{typeName}_Selectors.{SelectorFieldName(m.Selector)}";
        var retType = m.ReturnType;
        var retCall = MapReturnCall(retType);

        // Build parameter list
        var paramList = new List<string>();
        foreach (var p in m.Parameters)
        {
            paramList.Add($"{p.Type} {p.Name}");
        }
        if (m.HasErrorOut) paramList.Add("out NSError error");

        var paramsStr = string.Join(", ", paramList);
        var staticMod = isStatic ? "static " : "";
        var receiver = isStatic ? "s_class" : "NativePtr";

        sb.AppendLine($"    public {staticMod}{retType} {m.Name}({paramsStr})");
        sb.AppendLine("    {");

        // Build args for objc_msgSend
        var argParts = new List<string> { receiver, selField };
        foreach (var p in m.Parameters)
        {
            argParts.Add(UnwrapParam(p.Type, p.Name));
        }
        if (m.HasErrorOut) argParts.Add("out error");

        var argsStr = string.Join(", ", argParts);

        if (retType == "void")
        {
            sb.AppendLine($"        ObjectiveCRuntime.objc_msgSend({argsStr});");
        }
        else
        {
            sb.AppendLine($"        var __result = {retCall.Invoke}({argsStr});");
            sb.AppendLine($"        return {WrapReturnVar(retType, "__result")};");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>Maps a C# type to the correct objc_msgSend variant and wrapping.</summary>
    private static (string Invoke, bool NeedsWrap) MapReturnCall(string type)
    {
        return type switch
        {
            "void" => ("ObjectiveCRuntime.objc_msgSend", false),
            "Bool8" or "bool" => ("ObjectiveCRuntime.bool8_objc_msgSend", false),
            "uint" => ("ObjectiveCRuntime.uint_objc_msgSend", false),
            "ulong" => ("ObjectiveCRuntime.ulong_objc_msgSend", false),
            "float" => ("ObjectiveCRuntime.float_objc_msgSend", false),
            "double" => ("ObjectiveCRuntime.double_objc_msgSend", false),
            "UIntPtr" or "nuint" => ("ObjectiveCRuntime.UIntPtr_objc_msgSend", false),
            "IntPtr" or "nint" => ("ObjectiveCRuntime.intptr_objc_msgSend", false),
            // Value structs cannot be returned via intptr_objc_msgSend; skip generation.
            _ when IsKnownValueStruct(type) => ("/* TODO: stret */", false),
            // Anything else (struct wrappers like MTLCommandQueue, NSString, etc.)
            // is returned as IntPtr and wrapped in the struct constructor.
            _ => ("ObjectiveCRuntime.intptr_objc_msgSend", true),
        };
    }

    private static string WrapReturn(string type, string expr)
    {
        var call = MapReturnCall(type);
        if (!call.NeedsWrap) return expr;
        return $"new {type}({expr})";
    }

    private static string WrapReturnVar(string type, string varName)
    {
        var call = MapReturnCall(type);
        if (!call.NeedsWrap) return varName;
        return $"new {type}({varName})";
    }

    private static string MapSetCall(string type)
    {
        // All setters go through objc_msgSend; the difference is in how we unwrap the value.
        return "objc_msgSend";
    }

    /// <summary>
    /// Convert a parameter to the form needed for objc_msgSend.
    /// All register-sized values are cast to IntPtr to match uniform overloads.
    /// Value structs and float/double are passed as-is.
    /// </summary>
    private static string UnwrapParam(string type, string name)
    {
        // Value structs are passed by value directly
        if (IsKnownValueStruct(type)) return name;

        // Float/double have dedicated overloads
        if (type is "float" or "double") return name;

        // IntPtr is already the target type
        if (type is "IntPtr" or "nint") return name;

        // UIntPtr → IntPtr (same register size)
        if (type is "UIntPtr" or "nuint") return $"(IntPtr){name}";

        // ObjC wrappers → .NativePtr (which is IntPtr)
        if (IsObjCWrapper(type)) return $"{name}.NativePtr";

        // Bool8 → IntPtr
        if (type is "Bool8") return $"(IntPtr){name}.Value";
        if (type is "bool") return $"(IntPtr)({name} ? 1 : 0)";

        // Numeric primitives → IntPtr
        if (type is "uint" or "int" or "byte" or "sbyte" or "short" or "ushort")
            return $"(IntPtr){name}";
        if (type is "ulong" or "long")
            return $"(IntPtr){name}";

        // Enum types → IntPtr via uint
        if (IsLikelyEnum(type)) return $"(IntPtr)(uint){name}";

        // Fallback — assume ObjC wrapper
        return $"(IntPtr){name}";
    }

    private static bool IsObjCWrapper(string type)
    {
        // ObjC wrapper types: start with MTL/NS/CA, not value structs, not enums, not primitives
        if (IsKnownValueStruct(type) || IsLikelyEnum(type)) return false;
        return type.StartsWith("MTL") || type.StartsWith("NS") || type.StartsWith("CA");
    }

    private static bool IsKnownValueStruct(string type)
    {
        return type is "MTLOrigin" or "MTLSize" or "MTLRegion" or "MTLViewport"
            or "MTLScissorRect" or "MTLClearColor" or "MTLSamplePosition" or "CGSize";
    }

    // Known ObjC wrapper class/protocol types that should NOT be treated as enums
    // even though their names end with enum-like suffixes.
    private static readonly System.Collections.Generic.HashSet<string> s_knownWrapperTypes = new()
    {
        "MTLFunction", "MTLCompileOptions", "MTLComputePipelineState",
        "MTLRenderPipelineState", "MTLDepthStencilState", "MTLSamplerState",
        "MTLFence", "MTLRenderPassDescriptor", "MTLVertexDescriptor",
        "MTLRenderPipelineColorAttachmentDescriptor",
        "MTLRenderPipelineColorAttachmentDescriptorArray",
        "MTLRenderPassColorAttachmentDescriptor",
        "MTLRenderPassColorAttachmentDescriptorArray",
        "MTLRenderPassDepthAttachmentDescriptor",
        "MTLRenderPassStencilAttachmentDescriptor",
        "MTLVertexBufferLayoutDescriptor",
        "MTLVertexBufferLayoutDescriptorArray",
        "MTLVertexAttributeDescriptor",
        "MTLVertexAttributeDescriptorArray",
        "MTLStencilDescriptor",
    };

    private static bool IsLikelyEnum(string type)
    {
        // Exclude known wrapper types first
        if (s_knownWrapperTypes.Contains(type)) return false;

        // Enum types in Metal follow a naming convention
        if (!type.StartsWith("MTL")) return false;
        return type.Contains("Format")
            || type.EndsWith("Action") || type.EndsWith("Mode") || type.EndsWith("Type")
            || type.EndsWith("Function") || type.EndsWith("Operation") || type.EndsWith("Factor")
            || type.EndsWith("Mask") || type.EndsWith("Options") || type.EndsWith("Filter")
            || type.EndsWith("Usage") || type.EndsWith("Version") || type.EndsWith("Status")
            || type.EndsWith("Set") || type.EndsWith("Winding");
    }

    private static void AddSelector(Dictionary<string, string> dict, string selector)
    {
        if (!dict.ContainsKey(selector))
        {
            dict[selector] = SelectorFieldName(selector);
        }
    }

    private static string SelectorFieldName(string selector)
    {
        // "newBufferWithLength:options:" -> "newBufferWithLength_options_"
        return selector.Replace(":", "_");
    }

    private static string Capitalize(string s)
    {
        if (string.IsNullOrEmpty(s)) return s;
        return char.ToUpperInvariant(s[0]) + s.Substring(1);
    }
}
